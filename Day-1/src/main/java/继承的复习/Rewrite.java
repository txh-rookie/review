package 继承的复习;

/**
 * @author kevintam
 * @version 1.0
 * @title
 * @description
 * @createDate 2022/8/15
 */
public class Rewrite {
    /**
     * 方法重写
     *  子类继承父类，子类就得到父类的某个方法，但是子类觉得父类的这个方法不好用或者无法满足自己的需求
     *  子类重写一个与父类申明一样的方法来覆盖父类的该方法，子类的这个方法就进行了方法重写。
     *
     *  方法重写的校验注解:@Override
     *    java建议在重写的方法加上一个@Override注解
     *    方法一旦加了这个注解，那就必须是成功重写父类的方法，否则报错！
     *
     *  方法重写的要求:
     *    1、子类重写方法的名称和形参必须与父类的一摸一样。
     *    2、子类重写方法的返回值申明要么跟父类一摸一样，要么范围要小于父类。
     *    3、子类重写方法的修饰符应该与父类相同或者权限更大。
     *    4、子类重写方法申明抛出的异常应该与父类重写方法申明抛出的异常一样或者范围更小。
     *  方法重写的规范：
     *    1、加上@Overirrde
     *    2、建议"申明不变，重新实现"
     *
     *  supper就是当前对象的父类的引用。
     *  supper可以用在实例方法中调用父类的方法。
     *
     *   私有方法和静态方法能够被重写吗
     *    不能。
     *    私有方法只能在本类中进行使用，你没有办法在子类中使用父类的私有方法。
     *    静态方法是属于父类的，并且没有继承给子类，都没有继承，何来的重写呢？
     *
     *   子类的构造器的特点：
     *     子类构造器默认一定会访问父类的无参数构造器，再执行子类自己的构造器。
     *   为什么子类构造器会先调用父类构造器？
     *     1、子类的构造器第一行默认会有一个supper()调用父类的无参数构造器，写不写都存在！
     *     2、子类继承父类，获取到父类的属性和行为。
     *       当我们调用子类的构造器的初始化子类的对象时，必须先调用父类的构造器进行初始化父类，才能够使用父类的属性和方法。
     *       （先有爸爸，再有儿子）
     *
     *   supper调用父类的有参构造器特点：
     *     根据你传入参数的个数来继续匹配
     */
    public static void main(String[] args) {
        new Student();
    }
}
class People{
  public People(){
      System.out.println("父类无参数的构造器");
  }
  public People(String name){
      System.out.println("有参数的构造器。。。。");
  }
}
class Student extends People{
    public Student(){
        System.out.println("子类构造器。。。。");
    }
    public Student(String name){
        System.out.println("有参数的子类构造器");
    }
}
